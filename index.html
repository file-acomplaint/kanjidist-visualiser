<!DOCTYPE html>
<html>
<head>
    <title>Interactive Scatter Plot</title>
    <meta charset="UTF-8">
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="focused_mds.js"></script>
    <style> /* Basic styling */
        #scatterplot-container {
            margin: 0px auto;
            border: 1px solid #fff;
        }
    </style>
</head>
<body>
    
    <div style="overflow: hidden;">
        <div style="text-align: center; float: left;">
            <div id="scatterplot-container" style="border: 1px dotted black;"></div>
            <p>Map based on <span id="knum"></span> kanji<br> (reload to center at random position)</p>
        </div>

        <div id="kanji-container" style="float: right;">
             <iframe id="jisho-frame" src="about:blank" width="450" height="600"></iframe>
             <p>Show kanji info from <select name="Dictionary" id="dictSelect">
                <option value="jisho.org">jisho.org</option>
                <option value="jotoba.de">jotoba.de</option>
            </select>: <input type="checkbox" id="showJisho"> 
                
            </p>
        </div>
    </div>
    
    <script>
        const NUM_NEIGHBORS = 10;
        const jishoEnabled = false;
        const URLs = {"jotoba.de": ["https://jotoba.de/search/1/", "l=en-US"], "jisho.org": ["https://jisho.org/search/", " #kanji"]}
        const dictSelect = document.getElementById("dictSelect");

        async function loadData(fileName) {
            const response = await fetch(fileName);
            const data = await response.json();
            let chars = {};
            var stateInfo = [];

            const triangular = data.nearest == null;
            var inverted = data.inverted ? true : false;
            const scale = data.scaleBy;
            if (triangular) {
                for (let i = 0; i < data.characters.length; i++) {
                    chars[data.characters[i]] = i;
                    stateInfo.push({name:data.characters[i]})
                }
            } else {
                var k = 0;
                for (key in data.nearest) {
                    stateInfo.push({name:key});
                    chars[key] = k;
                    k += 1
                }
            }
            
            function getDistanceByIndex(i1,i2) {
                if (i1 > i2) {
                    const temp = i2;
                    i2 = i1;
                    i1 = temp;
                }

                return (data.distances[i1][i2-i1-1])/0.25;
            }
            
            function getDistance(a,b) {
                // We assume a != b
                var dist;
                if (triangular) {
                    const i1 = chars[a];
                    const i2 = chars[b];
                    dist =  getDistanceByIndex(i1,i2);
                } else {
                    var dist = data.nearest[a][b];
                    if (data.nearest[a][b] == undefined) {
                        dist = data.nearest[b][a];
                    }
                }
                dist = inverted ? 1 - dist : dist;
                dist *= 0.85 * scale * width;
                return dist;
            }

            // function kanjiPairHash(k1, k2) {
            //     let sortedPair = [k1.name, k2.name].sort();
            //     return sortedPair[0] + "-" + sortedPair[1];
            // }

            const width = 600;
            const height = 600;

            // Basic SVG setup
            const svg = d3.select("#scatterplot-container")
                .append("svg")
                .attr("width", width)
                .attr("height", height);

            // Scales for positioning
            const xScale = d3.scaleLinear()
                .domain([-width / 2, width / 2]) 
                .range([0, width]);
            const yScale = d3.scaleLinear()
                .domain([-height / 2, height / 2])
                .range([-height/2, height/2]);

            // Function to calculate positions based on a pivot point
            function updatePositions(pivotPoint) {
                var selected;
                var distances;

                if (triangular) {
                    distances = stateInfo
                    .filter(p => p !== pivotPoint) // Exclude the pivot point itself
                    .map(p => ({ ...p, distance: getDistance(p.name, pivotPoint.name)}))
                    .sort((a, b) => a.distance - b.distance); 
                    selected = distances.slice(0, NUM_NEIGHBORS).map(object => object.name);
                } else {
                    selected = Object.keys(data.nearest[pivotPoint.name]);
                }

                if (document.getElementById("showJisho").checked) { // Displaying additional information in an iframe
                    var hyperlink = URLs[dictSelect.value][0] + encodeURIComponent(pivotPoint.name + URLs[dictSelect.value][1]);
                    console.log(hyperlink)
                    document.getElementById("jisho-frame").src = hyperlink;
                }

                var j = 0;
                var pos_dict = {};
                var point_dict = {};
                function loss(point, theta, x, y, addLinks = false) {
                    // As in https://lea-urpa.github.io/focusedMDS.html
                    var out = 0;
                    const name = point.name;
                    
                    for (const [key, coords] of Object.entries(pos_dict)) {
                        var actual_dist = getDistance(key, name);
                        
                        // If a distance value is not recorded in the nearest neighbors, we set it to a large value.
                        if (!(actual_dist > 0)) { 
                            actual_dist = width*0.67;
                        } else if (addLinks) {
                            const [p, q] = point.name < point_dict[key].name ? [point, point_dict[key]] : [point_dict[key], point];
                            linkData.push({"source": p, "target": q, "dist": actual_dist, "id": p.name + "-" + q.name});
                        }
                        const euclidean = Math.sqrt((coords[0] - x)**2 + (coords[1] - y)**2) 
                        out += (1.25*actual_dist - euclidean)**2 // The original focusedMDS loss
                        if (euclidean < 250) {
                            out += 49999 / euclidean
                        }
                    }
                    if (out == 0) {return Infinity}
                    return out;
                }

                function xFromAngle(angle, distance) {
                    return distance * Math.cos(angle) + width/2
                }
                function yFromAngle(angle, distance) {
                    return distance * Math.sin(angle) + height/2
                }

                var display = [];
                var linkData = [];
                stateInfo.forEach(point => {
                    if (selected.includes(point.name)) {

                        var distance = getDistance(point.name, pivotPoint.name);
                        // Deciding an angle to put the new point at. We just do the most naive search for now... 
                        var min_loss = Infinity;
                        var min_angle = 2*Math.PI*Math.random();

                        for (var theta = 0; theta < 2*Math.PI; theta += 0.1) {
                            const l = loss(point, theta, xFromAngle(theta, distance), yFromAngle(theta, distance), theta == 0);
                            
                            if (l < min_loss) {
                                min_loss = l;
                                min_angle = theta;
                            }
                        }
                        
                        if (j != 0 || point.angle == undefined) {
                            point.angle = min_angle;
                        }

                        // If the point is newly included, we first set it to a large radius at the correct angle, so that it comes flying in from a sensible direction.
                        // distance = !point.outer ? 1000 : getDistance(point.name, pivotPoint.name);
                        point.outer = true;
                        point.distance = distance;
                        point.prevX = point.x;
                        point.prevY = point.y;
                        point.x = xFromAngle(point.angle, distance);
                        point.y = yFromAngle(point.angle, distance);
                        
                        pos_dict[point.name] = [point.x, point.y];
                        point_dict[point.name] = point;
                        j++;
                        const [p, q] = point.name < pivotPoint.name ? [point, pivotPoint] : [pivotPoint, point];
                        linkData.push({"source": p, "target": q, "dist": point.distance, "id": p.name + "-" + q.name});
                        display.push(point);
                    } else if (point.name != pivotPoint.name) {
                        point.outer = false;
                        point.x = width/2;
                        point.y = -height;
                    } else {
                        point.outer = false;
                        point.distance = 0;
                        display.push(point);
                    }
                });



                pivotPoint.outer = false;
                pivotPoint.x = width/2;
                pivotPoint.y = height/2;

                updatePlot(display, linkData);
                
            }

            function updatePlot(pointData, linkData) {
                const grayScale = d3.scaleLinear()
                .domain([0, 1])
                .range(["#000", "#ccc"]); // Gradient from black to light gray

                const colorScale = d3.scaleLinear()
                .domain([0.3, 1])
                .range(["#a40", "#fa5"]); // Gradient from red to white

                svg.append("g").attr("id", "links")
                svg.append("g").attr("id", "nodes")

                const circles = svg.select("#nodes").selectAll("circle")
                    .data(pointData, d => d.name);
                
                const links = svg.select("#links").selectAll("line")
                    .data(linkData, d => d.id);

                // Exiting links
                links.exit().transition().duration(500).style("opacity", 0).remove();

                // Entering links
                const enteringLinks = links.enter()
                    .append("line")
                    .style("stroke", d => grayScale(1.8 * d.dist / width))
                    .style("stroke-width", d => 5 - 12 * d.dist / width)
                    .attr("opacity", 0)
                    .attr("x1", d => d.source.x) 
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.source.x)
                    .attr("y2", d => d.source.y);                

                // Updating links
                enteringLinks.merge(links)
                    .each(function(d) { // Log values before starting the transition: These are the values where the edges *go*
                                        // (source and target are the ordered endpoints of the edges,
                                        // has nothing to do with source and target of the transition)
                        console.log(`Edges after transition: id ${d.id}, source (${d.source.x}, ${d.source.y}), target (${d.target.x}, ${d.target.y})`);
                    })
                    .transition()
                    .duration(1000)
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y)
                    .transition()
                    .duration(500)
                    .attr("opacity", 1);

                    console.log(`eol`);
    
                const enteringCircles = circles.enter()
                    .append("circle")
                    .attr("opacity", 0)
                    .attr("stroke", "#a40")
                    .attr("stroke-width", 2)
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);

                enteringCircles.merge(circles)
                    .transition()
                    .duration(1000)
                    .attr("opacity", 1)
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y)
                    .attr("fill", d => colorScale(2*d.distance/width))
                    .attr("r", 15);
                
                // Exiting Points
                circles.exit().transition().duration(500).style("opacity", 0).remove();

                const textLabels = svg.select("#nodes").selectAll("text")
                    .data(pointData, d => d.name);

                const enteringText = textLabels.enter()
                    .append("text")
                    .text(d => d.name) // Display the kanji
                    .attr("text-anchor", "middle") // Center text 
                    .attr("dy", ".35em")
                    .on("click", updatePositions)
                    .attr("x", d => d.x)
                    .attr("y", d => d.y);
                
                enteringText.merge(textLabels) 
                    .transition()
                    .duration(1000)
                    .attr("x", d => d.x)
                    .attr("y", d => d.y)
                    .attr("fill", "white")
                    .attr("opacity", d => 1.25-d.distance/width);
                // Exiting Text
                textLabels.exit().transition().duration(500).style("opacity", 0).remove();

            }

            // Initial Setup
            let currentPivot = stateInfo[Math.floor(Math.random() * stateInfo.length)];
            document.getElementById("knum").innerHTML = stateInfo.length;
            updatePositions(currentPivot);
        }

        loadData('data/dstrokedit.json');
    </script>
</body>
</html>