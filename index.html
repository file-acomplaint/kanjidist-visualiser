<!DOCTYPE html>
<html>
<head>
    <title>Kanji Distance Map</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@1.0.0/css/bulma.min.css">
</head>
    <script src="focused_mds.js"></script>
    <style> /* Basic styling */
        #scatterplot-container {
            margin: 0px auto;
            border: 1px solid #fff;
        }
    </style>
</head>
<body>
    <section class="section">
        <div class="container">
            
            <h1 class="title">The J≈çy≈ç Kanji Map | Âú∞Âõ≥„ÅßÂàÜ„Åã„ÇãÂ∏∏Áî®Êº¢Â≠ó  </h1>

            <div class="box">
                <div  class="columns is-centered">
                    <div id="kanjiplot-container column">
                        <svg id="kanjiplot"></svg>
                    </div>
                </div>
                <div class="columns is-centered">
                    <div class="column is-half">
                        <b>
                            What is this? üó∫Ô∏è
                        </b>
                        <p>It's an interactive way to arrange <span id="knum"></span> of the most common Japanese ideographic characters, called kanji, and highlight their structure. At the center, we can see the kanji we are focusing on. On the periphery, we can see its closest neighbors at a certain distance reflecting the similarity between them and the centered kanji. The peripheral kanji are also arranged roughly by how similar they are amongst themselves, with strong similarity being indicated by thicker lines. </p>
                        <div id="kanji-container" class="column is-narrow">
                            <iframe id="jisho-frame" src="about:blank" width="400" height="600"></iframe>
                       </div>
                    </div>
                    <div class="column is-half">
                        <b class=" is-h5">Controls</b>
                        <ul>
                            <li><p>
                                Select a Distance Map:
                                <select name="Dataset Selection" id="datasetSelection">
                                    <option value="dstrokedit.json">Stroke Edit Distance</option>
                                    <option value="dbagofradicals.json">Bag-of-Radicals Distance</option>
                                    
                                </select>
                            </p></li>

                        </ul>
                        
                        
                        <p>
                            <button id="randomButton" class="button">Jump to a Random Kanji!</button>
                            <button id="navigateButton" class="button">Jump to the kanji <input type="text" maxlength="1" style="text-align: center;" size="1" value="Êº†" id="navigateChar">!</button> 
                        </p>
                        
                        <p>Show kanji info from 
                            <select name="Dictionary" id="dictSelect">
                            <option value="jisho.org">jisho.org</option>
                            <option value="jotoba.de">jotoba.de</option>
                            </select>: <input type="checkbox" id="showJisho">
                        </p>
                    </div>
                </div>
            </div>

        </div>
      </section>
      <footer class="footer">
        <div class="content has-text-centered">
          <p>
            This website is brought to you by the <a href="http://www.stochastik.math.uni-goettingen.de/index.php?id=182&language=en">Spatial Stochastics</a> group at the <a href="https://www.uni-goettingen.de/en/1.html">University of G√∂ttingen</a>. <br>
            It uses <a href="https://github.com/d3/d3">d3.js</a>, licensed under <a href="https://www.isc.org/licenses/">ISC</a>, and <a href="https://github.com/jgthms/bulma">Bulma</a>, licensed under
            <a href="http://opensource.org/licenses/mit-license.php">MIT</a>. 
            The website content is licensed under <a href="http://opensource.org/licenses/mit-license.php">MIT</a>.
          </p>
        </div>
      </footer>
    
    
    <script>
        const NUM_NEIGHBORS = 10;
        const jishoEnabled = false;
        const URLs = {"jotoba.de": ["https://jotoba.de/search/1/", "l=en-US"], "jisho.org": ["https://jisho.org/search/", " #kanji"]}
        const dictSelect = document.getElementById("dictSelect");
        let currentPivot;

        async function loadData(fileName) {
            const response = await fetch(fileName);
            const data = await response.json();
            let chars = {};
            var stateInfo = [];

            const triangular = data.nearest == null;
            var inverted = data.inverted ? true : false;

            const scale = data.scaleBy;
            if (triangular) {
                for (let i = 0; i < data.characters.length; i++) {
                    chars[data.characters[i]] = i;
                    stateInfo.push({name:data.characters[i]})
                }
            } else {
                var k = 0;
                for (key in data.nearest) {
                    stateInfo.push({name:key});
                    chars[key] = k;
                    k += 1
                }
            }
            
            function getDistanceByIndex(i1,i2) {
                if (i1 > i2) {
                    const temp = i2;
                    i2 = i1;
                    i1 = temp;
                }

                return (data.distances[i1][i2-i1-1])/0.25;
            }
            
            function getDistance(a,b) {
                // We assume a != b
                var dist;
                if (triangular) {
                    const i1 = chars[a];
                    const i2 = chars[b];
                    dist =  getDistanceByIndex(i1,i2);
                } else {
                    var dist = data.nearest[a][b];
                    if (data.nearest[a][b] == undefined) {
                        dist = data.nearest[b][a];
                    }
                }
                dist = inverted ? 1 - dist : dist;
                dist *= 0.85 * scale * width;
                return dist;
            }

            // function kanjiPairHash(k1, k2) {
            //     let sortedPair = [k1.name, k2.name].sort();
            //     return sortedPair[0] + "-" + sortedPair[1];
            // }

            const width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
            const height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;

            // Basic SVG setup
            const svg = d3.select("#kanjiplot")
            .attr("viewBox", [0, 0, width, height])
            .attr("width", "100%")
            .attr("height", "auto");
            
            window.onresize = function () {
                width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
                height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
                svg.attr("viewBox", [0, 0, width, height])
                    .attr("width", width)
                    .attr("height", height);
            }

            // Scales for positioning
            const xScale = d3.scaleLinear()
                .domain([-width / 2, width / 2]) 
                .range([0, width]);
            const yScale = d3.scaleLinear()
                .domain([-height / 2, height / 2])
                .range([-height/2, height/2]);

            // Function to calculate positions based on a pivot point
            function updatePositions(pivotPoint) {
                currentPivot = pivotPoint;
                var selected;
                var distances;

                if (triangular) {
                    distances = stateInfo
                    .filter(p => p !== pivotPoint) // Exclude the pivot point itself
                    .map(p => ({ ...p, distance: getDistance(p.name, pivotPoint.name)}))
                    .sort((a, b) => a.distance - b.distance); 
                    selected = distances.slice(0, NUM_NEIGHBORS).map(object => object.name);
                } else {
                    selected = Object.keys(data.nearest[pivotPoint.name]);
                }

                const showDictionary = document.getElementById("showJisho").checked;
                document.getElementById("jisho-frame").style.display = showDictionary ? "inline" : "none";
                if (showDictionary) { // Displaying additional information in an iframe
                    var hyperlink = URLs[dictSelect.value][0] + encodeURIComponent(pivotPoint.name + URLs[dictSelect.value][1]);
                    console.log(hyperlink)
                    document.getElementById("jisho-frame").src = hyperlink;
                }

                var j = 0;
                var pos_dict = {};
                var point_dict = {};
                function loss(point, theta, x, y, addLinks = false) {
                    // As in https://lea-urpa.github.io/focusedMDS.html
                    var out = 0;
                    const name = point.name;
                    
                    for (const [key, coords] of Object.entries(pos_dict)) {
                        var actual_dist = getDistance(key, name);
                        
                        // If a distance value is not recorded in the nearest neighbors, we set it to a large value.
                        if (!(actual_dist > 0)) { 
                            actual_dist = width*0.67;
                        } else if (addLinks) {
                            const [p, q] = point.name < point_dict[key].name ? [point, point_dict[key]] : [point_dict[key], point];
                            linkData.push({"source": p, "target": q, "dist": actual_dist, "id": p.name + "-" + q.name});
                        }
                        const euclidean = Math.sqrt((coords[0] - x)**2 + (coords[1] - y)**2) 
                        out += (1.25*actual_dist - euclidean)**2 // The original focusedMDS loss
                        if (euclidean < 250) {
                            out += 49999 / euclidean
                        }
                    }
                    if (out == 0) {return Infinity}
                    return out;
                }

                function xFromAngle(angle, distance) {
                    return distance * Math.cos(angle) + width/2
                }
                function yFromAngle(angle, distance) {
                    return distance * Math.sin(angle) + height/2
                }

                var display = [];
                var linkData = [];
                stateInfo.forEach(point => {
                    if (selected.includes(point.name)) {

                        var distance = getDistance(point.name, pivotPoint.name);
                        // Deciding an angle to put the new point at. We just do the most naive search for now... 
                        var min_loss = Infinity;
                        var min_angle = 2*Math.PI*Math.random();

                        for (var theta = 0; theta < 2*Math.PI; theta += 0.1) {
                            const l = loss(point, theta, xFromAngle(theta, distance), yFromAngle(theta, distance), theta == 0);
                            
                            if (l < min_loss) {
                                min_loss = l;
                                min_angle = theta;
                            }
                        }
                        
                        if (j != 0 || point.angle == undefined) {
                            point.angle = min_angle;
                        }

                        // If the point is newly included, we first set it to a large radius at the correct angle, so that it comes flying in from a sensible direction.
                        // distance = !point.outer ? 1000 : getDistance(point.name, pivotPoint.name);
                        point.outer = true;
                        point.distance = distance;
                        point.prevX = point.x;
                        point.prevY = point.y;
                        point.x = xFromAngle(point.angle, distance);
                        point.y = yFromAngle(point.angle, distance);
                        
                        pos_dict[point.name] = [point.x, point.y];
                        point_dict[point.name] = point;
                        j++;
                        const [p, q] = point.name < pivotPoint.name ? [point, pivotPoint] : [pivotPoint, point];
                        linkData.push({"source": p, "target": q, "dist": point.distance, "id": p.name + "-" + q.name});
                        display.push(point);
                    } else if (point.name != pivotPoint.name) {
                        point.outer = false;
                        point.x = width/2;
                        point.y = -height;
                    } else {
                        point.outer = false;
                        point.distance = 0;
                        display.push(point);
                    }
                });



                pivotPoint.outer = false;
                pivotPoint.x = width/2;
                pivotPoint.y = height/2;

                updatePlot(display, linkData);
            }

            function updatePlot(pointData, linkData) {
                const grayScale = d3.scaleLinear()
                .domain([0, 1])
                .range(["#000", "#ccc"]); // Gradient from black to light gray

                const colorScale = d3.scaleLinear()
                .domain([0.3, 1])
                .range(["#a40", "#fa5"]); // Gradient from red to white

                svg.append("g").attr("id", "links")
                svg.append("g").attr("id", "nodes")

                const circles = svg.select("#nodes").selectAll("circle")
                    .data(pointData, d => d.name);
                
                const links = svg.select("#links").selectAll("line")
                    .data(linkData, d => d.id);

                // Exiting links
                links.exit().transition().duration(500).style("opacity", 0).remove();

                // Entering links
                const enteringLinks = links.enter()
                    .append("line")
                    .style("stroke", d => grayScale(1.8 * d.dist / width))
                    .style("stroke-width", d => 5 - 12 * d.dist / width)
                    .attr("opacity", 0)
                    .attr("x1", d => d.source.x) 
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.source.x)
                    .attr("y2", d => d.source.y);                

                // Updating links
                enteringLinks.merge(links)
                    .each(function(d) { // Log values before starting the transition: These are the values where the edges *go*
                                        // (source and target are the ordered endpoints of the edges,
                                        // has nothing to do with source and target of the transition)
                        // console.log(`Edges after transition: id ${d.id}, source (${d.source.x}, ${d.source.y}), target (${d.target.x}, ${d.target.y})`);
                    })
                    .transition()
                    .duration(1000)
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y)
                    .transition()
                    .duration(500)
                    .attr("opacity", 1);

                    // console.log(`eol`);
    
                const enteringCircles = circles.enter()
                    .append("circle")
                    .attr("opacity", 0)
                    .attr("stroke", "#a40")
                    .attr("stroke-width", 2)
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);

                enteringCircles.merge(circles)
                    .transition()
                    .duration(1000)
                    .attr("opacity", 1)
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y)
                    .attr("fill", d => colorScale(2*d.distance/width))
                    .attr("r", 15);
                
                // Exiting Points
                circles.exit().transition().duration(500).style("opacity", 0).remove();

                const textLabels = svg.select("#nodes").selectAll("text")
                    .data(pointData, d => d.name);

                const enteringText = textLabels.enter()
                    .append("text")
                    .text(d => d.name) // Display the kanji
                    .attr("text-anchor", "middle") // Center text 
                    .attr("dy", ".35em")
                    .on("click", updatePositions)
                    .attr("x", d => d.x)
                    .attr("y", d => d.y);
                
                enteringText.merge(textLabels) 
                    .transition()
                    .duration(1000)
                    .attr("x", d => d.x)
                    .attr("y", d => d.y)
                    .attr("fill", "white")
                    .attr("opacity", d => 1.25-d.distance/width);
                // Exiting Text
                textLabels.exit().transition().duration(500).style("opacity", 0).remove();

            }

            // Initial Setup
            if (currentPivot == undefined) {
                currentPivot = stateInfo[Math.floor(Math.random() * stateInfo.length)];
            } else {
                console.log(currentPivot);
                currentPivot = stateInfo.find(d => d.name == currentPivot.name);
            }
            document.getElementById("knum").innerHTML = stateInfo.length;
            document.getElementById("navigateButton").onclick = function() {
                try {
                    const ch = document.getElementById('navigateChar').value;
                    updatePositions(stateInfo.find(d => d.name == ch));
                } catch(e) {
                    alert("Sorry! That character is not included in the distance data.")
                    console.error(e)
                }
                
            };
            document.getElementById("randomButton").onclick = function() {updatePositions(stateInfo[Math.floor(Math.random() * stateInfo.length)]);};
            updatePositions(currentPivot);
        }

        updatePositions = loadData('data/dstrokedit.json');
        document.getElementById("datasetSelection").onchange = function() {
            loadData("data/" + document.getElementById("datasetSelection").value);
        }
        
    </script>
</body>
</html>
