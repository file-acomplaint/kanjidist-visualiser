<!DOCTYPE html>
<html>
<head>
    <title>Interactive Scatter Plot</title>
    <meta charset="UTF-8">
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="focused_mds.js"></script>
    <style> /* Basic styling */
        #scatterplot-container {
            margin: 20px auto;
            border: 1px solid #fff;
        }
    </style>
</head>
<body>
    
    <div style="overflow: hidden;">
        <div style="text-align: center; float: left;">
            <div id="scatterplot-container" style="border: 1px dotted black;"></div>
        </div>

        <div id="kanji-container" style="float: right;">
            <p>Show Kanji Info: <input type="checkbox" id="showJisho"></p>
            <iframe id="jisho-frame" src="about:blank" width="400" height="550" ></iframe>
        </div>
    </div>
    
    <script>
        const NUM_NEIGHBORS = 10;
        const jishoEnabled = false;
        async function loadData(fileName) {
            const response = await fetch(fileName);
            const data = await response.json();
            let chars = {};
            var stateInfo = [];

            const triangular = data.nearest == null;
            var inverted = data.inverted ? true : false;
            const scale = data.scaleBy;
            if (triangular) {
                for (let i = 0; i < data.characters.length; i++) {
                    chars[data.characters[i]] = i;
                    stateInfo.push({name:data.characters[i]})
                }
            } else {
                for (key in data.nearest) {
                    stateInfo.push({name:key})
                }
            }
            
            function getDistanceByIndex(i1,i2) {
                if (i1 > i2) {
                    const temp = i2;
                    i2 = i1;
                    i1 = temp;
                }

                return (data.distances[i1][i2-i1-1])/0.25;
            }
            
            function getDistance(a,b) {
                // We assume a != b
                var dist;
                if (triangular) {
                    const i1 = chars[a];
                    const i2 = chars[b];
                    dist =  getDistanceByIndex(i1,i2);
                } else {
                    var dist = data.nearest[a][b];
                    if (data.nearest[a][b] == undefined) {
                        dist = data.nearest[b][a];
                    }
                }
                dist = inverted ? 1 - dist : dist;
                dist *= scale * width;
                return dist;
            }

            const width = 500;
            const height = 500;

            // Basic SVG setup
            const svg = d3.select("#scatterplot-container")
                .append("svg")
                .attr("width", width)
                .attr("height", height);

            // Scales for positioning
            const xScale = d3.scaleLinear()
                .domain([-width / 2, width / 2]) 
                .range([0, width]);
            const yScale = d3.scaleLinear()
                .domain([-height / 2, height / 2])
                .range([-height/2, height/2]);

            // Function to calculate positions based on a pivot point
            function updatePositions(pivotPoint) {
                var selected;
                var distances;

                if (triangular) {
                    distances = stateInfo
                    .filter(p => p !== pivotPoint) // Exclude the pivot point itself
                    .map(p => ({ ...p, distance: getDistance(p.name, pivotPoint.name)}))
                    .sort((a, b) => a.distance - b.distance); 
                    selected = distances.slice(0, NUM_NEIGHBORS).map(object => object.name);
                } else {
                    selected = Object.keys(data.nearest[pivotPoint.name]);
                }

                if (document.getElementById("showJisho").checked) { // Displaying additional information in an iframe
                    var jishoUrl = "https://jisho.org/search/" + encodeURIComponent(pivotPoint.name + " #kanji");
                    document.getElementById("jisho-frame").src = jishoUrl;
                }

                var j = 0;
                var pos_dict = {};

                function loss(name, theta, x, y) {
                    // As in https://lea-urpa.github.io/focusedMDS.html
                    var out = 0;
                    
                    for (const [key, coords] of Object.entries(pos_dict)) {
                        var actual_dist = getDistance(key, name);
                        
                        // If a distance value is not recorded in the nearest neighbors, we set it to a large value.
                        if (!(actual_dist > 0)) { 
                            actual_dist = width*0.67;
                        }

                        const euclidean = Math.sqrt((coords[0] - x)**2 + (coords[1] - y)**2) 
                        
                        out += (1.25*actual_dist - euclidean)**2 // The original focusedMDS loss
                        if (euclidean < 250) {
                            out += 49999 / euclidean
                        }
                    }
                    if (out == 0) {return Infinity}
                    return out;
                }

                function xFromAngle(angle, distance) {
                    return distance * Math.cos(angle) + width/2
                }
                function yFromAngle(angle, distance) {
                    return distance * Math.sin(angle) + height/2
                }

                stateInfo.forEach(point => {
                    if (selected.includes(point.name)) {

                        var distance = getDistance(point.name, pivotPoint.name);
                        // Deciding an angle to put the new point at. We just do the most naive search for now... 
                        var min_loss = Infinity;
                        var min_angle = 2*Math.PI*Math.random();

                        for (var theta = 0; theta < 2*Math.PI; theta += 0.1) {
                            const l = loss(point.name, theta, xFromAngle(theta, distance), yFromAngle(theta, distance));
                            
                            if (l < min_loss) {
                                min_loss = l;
                                min_angle = theta;
                            }
                        }
                        
                        if (j != 0 || point.angle == undefined) {
                            point.angle = min_angle;
                        }

                        // If the point is newly included, we first set it to a large radius at the correct angle, so that it comes flying in from a sensible direction.
                        // distance = !point.outer ? 1000 : getDistance(point.name, pivotPoint.name);
                        point.outer = true;
                        point.distance = distance;
                        point.x = xFromAngle(point.angle, distance);
                        point.y = yFromAngle(point.angle, distance);
                        
                        pos_dict[point.name] = [point.x, point.y];
                        j++;
                    } else if (point.name != pivotPoint.name) {
                        point.outer = false;
                        point.x = width/2;
                        point.y = -height;
                    } else {
                        point.outer = false;
                        point.distance = 0;
                    }
                });

                pivotPoint.outer = false;
                pivotPoint.x = width/2;
                pivotPoint.y = height/2;

                updatePlot(stateInfo);
                
            }

            function updatePlot(data) {
                const circles = svg.selectAll("circle")
                    .data(data);

                circles.exit().remove();

                const colorScale = d3.scaleLinear()
                .domain([0.3, 1]) 
                .range(["#a40", "#fa5"]); // Gradient from red to white

                circles.enter()
                    .append("circle")
                    .attr("opacity", 0.8)
                    .attr("stroke", "#a40")
                    .attr("stroke-width", 2)
                    .merge(circles)
                    .transition()
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y)
                    .attr("fill", d => colorScale(2*d.distance/width))
                    .attr("r", 15);


                const textLabels = svg.selectAll("text")
                    .data(data);

                textLabels.exit().remove(); 

                textLabels.enter()
                    .append("text")
                    .text(d => d.name) // Display the kanji
                    .attr("text-anchor", "middle") // Center text 
                    .attr("dy", ".35em")
                    .on("click", updatePositions)
                    .merge(textLabels) 
                    .transition()
                    .attr("x", d => d.x)
                    .attr("y", d => d.y)
                    .attr("fill", "white")
                    .attr("opacity", d => 1.25-d.distance/width);

            }

            // Initial Setup
            let currentPivot = stateInfo[0]; 
            updatePositions(currentPivot);

            
        }

        loadData('data/dstrokedit.json');
    </script>
</body>
</html>